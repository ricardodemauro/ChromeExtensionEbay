{"version":3,"sources":["webpack:///webpack/bootstrap 0e619edf33f442ae79f7","webpack:///./app/index.js"],"names":["getCurrentTabUrl","callback","queryInfo","active","currentWindow","chrome","tabs","query","tab","url","console","assert","changeBackgroundColor","color","script","executeScript","code","getSavedBackgroundColor","storage","sync","get","items","runtime","lastError","saveBackgroundColor","set","document","addEventListener","dropdown","getElementById","savedColor","value"],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA,mDAA2C,cAAc;;AAEzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;;;;AChEA;AACA;AACA;;AAEA;;;;;;AAMA,SAASA,gBAAT,CAA0BC,QAA1B,EAAoC;AAClC;AACA;AACA,MAAIC,YAAY;AACdC,YAAQ,IADM;AAEdC,mBAAe;AAFD,GAAhB;;AAKAC,SAAOC,IAAP,CAAYC,KAAZ,CAAkBL,SAAlB,EAA6B,UAACI,IAAD,EAAU;AACrC;AACA;AACA;AACA;AACA;AACA,QAAIE,MAAMF,KAAK,CAAL,CAAV;;AAEA;AACA;AACA,QAAIG,MAAMD,IAAIC,GAAd;;AAEA;AACA;AACA;AACA;AACAC,YAAQC,MAAR,CAAe,OAAOF,GAAP,IAAc,QAA7B,EAAuC,4BAAvC;;AAEAR,aAASQ,GAAT;AACD,GAnBD;;AAqBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACD;;AAED;;;;;AAKA,SAASG,qBAAT,CAA+BC,KAA/B,EAAsC;AACpC,MAAIC,SAAS,0CAA0CD,KAA1C,GAAkD,IAA/D;AACA;AACA;AACA;AACA;AACA;AACAR,SAAOC,IAAP,CAAYS,aAAZ,CAA0B;AACxBC,UAAMF;AADkB,GAA1B;AAGD;;AAED;;;;;;;AAOA,SAASG,uBAAT,CAAiCR,GAAjC,EAAsCR,QAAtC,EAAgD;AAC9C;AACA;AACA;AACAI,SAAOa,OAAP,CAAeC,IAAf,CAAoBC,GAApB,CAAwBX,GAAxB,EAA6B,UAACY,KAAD,EAAW;AACtCpB,aAASI,OAAOiB,OAAP,CAAeC,SAAf,GAA2B,IAA3B,GAAkCF,MAAMZ,GAAN,CAA3C;AACD,GAFD;AAGD;;AAED;;;;;;AAMA,SAASe,mBAAT,CAA6Bf,GAA7B,EAAkCI,KAAlC,EAAyC;AACvC,MAAIQ,QAAQ,EAAZ;AACAA,QAAMZ,GAAN,IAAaI,KAAb;AACA;AACA;AACA;AACAR,SAAOa,OAAP,CAAeC,IAAf,CAAoBM,GAApB,CAAwBJ,KAAxB;AACD;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAK,SAASC,gBAAT,CAA0B,kBAA1B,EAA8C,YAAM;AAClD3B,mBAAiB,UAACS,GAAD,EAAS;AACxB,QAAImB,WAAWF,SAASG,cAAT,CAAwB,UAAxB,CAAf;;AAEA;AACA;AACAZ,4BAAwBR,GAAxB,EAA6B,UAACqB,UAAD,EAAgB;AAC3C,UAAIA,UAAJ,EAAgB;AACdlB,8BAAsBkB,UAAtB;AACAF,iBAASG,KAAT,GAAiBD,UAAjB;AACD;AACF,KALD;;AAOA;AACA;AACAF,aAASD,gBAAT,CAA0B,QAA1B,EAAoC,YAAM;AACxCf,4BAAsBgB,SAASG,KAA/B;AACAP,0BAAoBf,GAApB,EAAyBmB,SAASG,KAAlC;AACD,KAHD;AAID,GAlBD;AAmBD,CApBD,E","file":"bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 0e619edf33f442ae79f7","// Copyright (c) 2014 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n/**\n * Get the current URL.\n *\n * @param {function(string)} callback called when the URL of the current tab\n *   is found.\n */\nfunction getCurrentTabUrl(callback) {\n  // Query filter to be passed to chrome.tabs.query - see\n  // https://developer.chrome.com/extensions/tabs#method-query\n  var queryInfo = {\n    active: true,\n    currentWindow: true\n  };\n\n  chrome.tabs.query(queryInfo, (tabs) => {\n    // chrome.tabs.query invokes the callback with a list of tabs that match the\n    // query. When the popup is opened, there is certainly a window and at least\n    // one tab, so we can safely assume that |tabs| is a non-empty array.\n    // A window can only have one active tab at a time, so the array consists of\n    // exactly one tab.\n    var tab = tabs[0];\n\n    // A tab is a plain object that provides information about the tab.\n    // See https://developer.chrome.com/extensions/tabs#type-Tab\n    var url = tab.url;\n\n    // tab.url is only available if the \"activeTab\" permission is declared.\n    // If you want to see the URL of other tabs (e.g. after removing active:true\n    // from |queryInfo|), then the \"tabs\" permission is required to see their\n    // \"url\" properties.\n    console.assert(typeof url == 'string', 'tab.url should be a string');\n\n    callback(url);\n  });\n\n  // Most methods of the Chrome extension APIs are asynchronous. This means that\n  // you CANNOT do something like this:\n  //\n  // var url;\n  // chrome.tabs.query(queryInfo, (tabs) => {\n  //   url = tabs[0].url;\n  // });\n  // alert(url); // Shows \"undefined\", because chrome.tabs.query is async.\n}\n\n/**\n * Change the background color of the current page.\n *\n * @param {string} color The new background color.\n */\nfunction changeBackgroundColor(color) {\n  var script = 'document.body.style.backgroundColor=\"' + color + '\";';\n  // See https://developer.chrome.com/extensions/tabs#method-executeScript.\n  // chrome.tabs.executeScript allows us to programmatically inject JavaScript\n  // into a page. Since we omit the optional first argument \"tabId\", the script\n  // is inserted into the active tab of the current window, which serves as the\n  // default.\n  chrome.tabs.executeScript({\n    code: script\n  });\n}\n\n/**\n * Gets the saved background color for url.\n *\n * @param {string} url URL whose background color is to be retrieved.\n * @param {function(string)} callback called with the saved background color for\n *     the given url on success, or a falsy value if no color is retrieved.\n */\nfunction getSavedBackgroundColor(url, callback) {\n  // See https://developer.chrome.com/apps/storage#type-StorageArea. We check\n  // for chrome.runtime.lastError to ensure correctness even when the API call\n  // fails.\n  chrome.storage.sync.get(url, (items) => {\n    callback(chrome.runtime.lastError ? null : items[url]);\n  });\n}\n\n/**\n * Sets the given background color for url.\n *\n * @param {string} url URL for which background color is to be saved.\n * @param {string} color The background color to be saved.\n */\nfunction saveBackgroundColor(url, color) {\n  var items = {};\n  items[url] = color;\n  // See https://developer.chrome.com/apps/storage#type-StorageArea. We omit the\n  // optional callback since we don't need to perform any action once the\n  // background color is saved.\n  chrome.storage.sync.set(items);\n}\n\n// This extension loads the saved background color for the current tab if one\n// exists. The user can select a new background color from the dropdown for the\n// current page, and it will be saved as part of the extension's isolated\n// storage. The chrome.storage API is used for this purpose. This is different\n// from the window.localStorage API, which is synchronous and stores data bound\n// to a document's origin. Also, using chrome.storage.sync instead of\n// chrome.storage.local allows the extension data to be synced across multiple\n// user devices.\ndocument.addEventListener('DOMContentLoaded', () => {\n  getCurrentTabUrl((url) => {\n    var dropdown = document.getElementById('dropdown');\n\n    // Load the saved background color for this page and modify the dropdown\n    // value, if needed.\n    getSavedBackgroundColor(url, (savedColor) => {\n      if (savedColor) {\n        changeBackgroundColor(savedColor);\n        dropdown.value = savedColor;\n      }\n    });\n\n    // Ensure the background color is changed and saved when the dropdown\n    // selection changes.\n    dropdown.addEventListener('change', () => {\n      changeBackgroundColor(dropdown.value);\n      saveBackgroundColor(url, dropdown.value);\n    });\n  });\n});\n\n\n\n// WEBPACK FOOTER //\n// ./app/index.js"],"sourceRoot":""}